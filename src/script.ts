import { Script } from '@script_types/script/script';
import { SourceMusicPlayer } from '@script_types/sources/media/source_music_player';
import { ScriptConfig } from '../gen/spec_config'; /* File will be automatically generated by compiler! Run "nom run cli install" */
import { specification } from './spec';
import { MopidyAPI } from './mopidy_api_types';
import { ScriptCtxUI } from '@script_types/script/context_ui/context_ui';

type RpcPromiseReturn = (ret: { err?: string, result?: MopidyAPI.RpcRequests['r']}) => void;
interface PendingRpcReq {
    t_send: number;
    timeout: NodeJS.Timeout;
    resolve: RpcPromiseReturn;
}

interface SocketInfo {
    uid: string
}

let LOG_VERBOSE = false;

export class MyScript implements Script.Class<ScriptConfig> {
    private ctx_: Script.Context | undefined;

    private msg_id_counter = 0;
    private rpc_req_map: {[key: number]: PendingRpcReq} = {};

    private playstate: SourceMusicPlayer.PlayState = {
        state: "stopped"
    };

    private socket_info: SocketInfo | undefined;
    private ws_url: string | undefined;

    start = async (ctx: Script.Context, config: ScriptConfig): Promise<void> => {
    
        console.info("Ident:" + specification.id_ident);
        console.info("Config:" + JSON.stringify(config));
        this.ctx_ = ctx;

        if (config.verbose_log?.value) {
            LOG_VERBOSE = true;
        }
        const handleSubscriptionResult = (result: { error: string | undefined }) => {
            if (result.error) console.error(result.error);
        }

        ctx.ui.subscribeDataRequests<"music_player">("music_player", this.dataRequest).then(handleSubscriptionResult);
        ctx.ui.subscribeCommands<"music_player">("music_player", this.executeCommand).then(handleSubscriptionResult);

        let host = config.host?.value;
        if (host) {
            if (!host.startsWith("ws://")) {
                host = "ws://" + host;
            }
            console.debug("split test: ", host.split(":"));
            if (host.split(":").length == 2) { // there is one in ws://, check if the one for the port exists, should be 3 elements. If only 2, add the port
                host = host + ":6680";
            }
            const url = host + "/mopidy/ws/";
            console.log(`Used url is: ${url}`);
            this.ws_url = url;
        } else {
            console.warn("host parameter not set");
        }

        this.tryConnect();
        console.log("Start done!");
    }

    stop = async (_reason: Script.StopReason): Promise<void> => {
        console.info("Stopping all my stuff ...");
    }

    private tryConnect = async () => {
        if (this.ctx_) {
            if (!this.ws_url) {
                console.warn("url not set, cannot connect");
                return;
            }

            console.log(`Connecting to ${this.ws_url} ...`)
            let socket_info: SocketInfo = { uid: "" };
            let ret = await this.ctx_.data.websocket.connect(this.ws_url, this.rcvDataFromWebsocket, { 
                auto_reconnect: true,
                state_handler: (state) => {
                    console.log("Websocket:StateChanged:1:", state);
                    console.info("Websocket:StateChanged: " + (state.connected ? "connect" : "closed"));
                    if (!state.connected) {
                        this.socket_info = undefined;
                    } else {
                        socket_info.uid = state.uid ;
                        if (!this.socket_info) {
                            this.socket_info = socket_info; // re-set the socket info! It might have been deleted at disconnect!
                        }
                    }
                }
            });
            if (ret.uid) {
                console.info("Mopidy Websocket Connected");
                this.socket_info = socket_info;

                await this.getState();
                // Send the inital state:
                this.transmitPlaystate();
            } else {
                console.error("Mopidy Websocket Connect Failed: " + ret.error);
                if (ret.error) {
                    setTimeout(this.tryConnect, 5000); // Retry the initial connect
                }
            }
        }
    }
    
    private getDataEventFromCache = (event?: SourceMusicPlayer.Event): SourceMusicPlayer.Data=> {
        return {
            event,
            play_state: this.playstate
        }
    }

    private transmitPlaystate = () => {
        if (this.ctx_) {
            const data_o: SourceMusicPlayer.Data = this.getDataEventFromCache();
            this.ctx_.ui.transmitData("music_player", data_o);
        }
    }

    private getState = async () => {
        await this.getPlayState();
        let track_o = await this.modpidyGetCurrentTrack();
        let pos_o   = await this.mopidyGetTimePosition();
        let muted_o = await this.mopidyGetMuted();
        if (track_o) {
            this.playstate.track = {
                name: track_o.name,
                uri:  track_o.uri
            }
            if (track_o.artists) {
                this.playstate.track.artists = track_o.artists.map(e => { return {
                    name: e.name,
                    uri: e.uri
                }});
            }
            if (track_o.album) {
                this.playstate.track.album = {
                    name: track_o.album.name,
                    uri: track_o.album.uri,
                    artists: track_o.artists,
                    date: track_o.date
                }
            }
            if (!this.playstate.settings) {
                this.playstate.settings = {};
            }
            if (muted_o !== undefined) {
                this.playstate.settings.muted = muted_o;
            }
            let uri = track_o.uri;
            
            let image_o = await this.modpidyGetImageForUri(uri);
            if (image_o) {
                this.playstate.track.image = {
                    http_url: image_o.uri
                };
            }
            if (typeof pos_o == "number") {
                this.playstate.timing = {
                    position_ms: pos_o
                }
            } else {
                delete this.playstate.timing;
            }
            console.info("getState:result: new playstate: ", this.playstate);
        }
    }

    private sendToWebsocket = (str: string) => {
        if (this.socket_info && this.ctx_) {
            this.ctx_.data.websocket.sendData(this.socket_info.uid, str);
        } else {
            console.error("sendToWebsocket, ws_uid missing!");
        }
    }

    private sendRpcMessage = async <T extends MopidyAPI.RpcRequests>(req: T): Promise<{ err?: string, result: T['r']}> => {
        this.msg_id_counter++;
        if (this.msg_id_counter > 4294967296) {
            this.msg_id_counter = 0;
        }
        return new Promise<{ err?: string, result: T['r']}>((resolve) => {
            const req_id = this.msg_id_counter;
            this.rpc_req_map[req_id] = {
                resolve: <any> resolve,
                t_send: Date.now(),
                timeout: setTimeout(() => {
                    let req_o = this.rpc_req_map[req_id];
                    if (req_o) {
                        console.error(`RpcRequest [ ${req_id} ] timed out!`);
                        req_o.resolve({ err: "Timeout" });
                    }
                    delete this.rpc_req_map[req_id];
                }, 1000)
            }
            const msg_o: MopidyAPI.RpcRequest = {
                jsonrpc: "2.0",
                id: req_id,
                method: req.method
            }
            if (req.params) {
                msg_o.params = req.params
            }
            this.sendToWebsocket(JSON.stringify(msg_o));
        });
    }

    // @ts-ignore
    private playTracklist = async (playlist_uri: string)  => {
        let res_items = await this.sendRpcMessage<MopidyAPI.ReqPlaylistGetItems>({ method: "core.playlists.get_items", params: { uri: playlist_uri } });
        if (res_items.result) {
            let playlist_items = res_items.result;
            await this.sendRpcMessage<MopidyAPI.ReqTracklistClear>({ method: 'core.tracklist.clear'});
            let res_add = await this.sendRpcMessage<MopidyAPI.ReqTracklistAdd>({ method: 'core.tracklist.add', params: {
                uris: playlist_items.map(e => e.uri)
            }});
            if (res_add.result) {
                let tl_tracks = res_add.result;
                if (tl_tracks.length > 0) {
                    await this.sendRpcMessage<MopidyAPI.ReqPlaybackPlay>({ method: 'core.playback.play', params: { tlid: tl_tracks[0].tlid }});
                }
            }
        }
    }

    private mopidyGetTrackList = async (): Promise<MopidyAPI.TlTrack[]> => {
        let ret_o = await this.sendRpcMessage<MopidyAPI.ReqTracklistGetTracks>({ method: "core.tracklist.get_tl_tracks" });
        if (ret_o.result) {
            return ret_o.result;
        } else {
            return [];
        }
    }

    private mopidyGetTimePosition = async (): Promise<number | undefined> => {
        let ret_o = await this.sendRpcMessage<MopidyAPI.ReqPlaybackGetTimnePosition>( { method: "core.playback.get_time_position"});
        if (ret_o.result !== undefined && ret_o.result !== null) {
            return ret_o.result;
        }
        return undefined;
    }

    private mopidyGetMuted = async (): Promise<boolean | undefined> => {
        let ret_o = await this.sendRpcMessage<MopidyAPI.ReqMixerGetMute>( { method: "core.mixer.get_mute"});
        if (ret_o.result !== undefined && ret_o.result !== null) {
            return ret_o.result;
        }
        return undefined;
    }

    private modpidyGetCurrentTrack = async (): Promise<MopidyAPI.Track | undefined> => {
        let ret_o = await this.sendRpcMessage<MopidyAPI.ReqPlaybackGetCurrentTrack>({ method: "core.playback.get_current_track" });
        if (ret_o.result) {
            return ret_o.result;
        } else {
            return undefined;
        }
    }
    private modpidyGetImageForUri = async (uri: string) => {
        let ret = await this.modpidyGetImagesForUris( [ uri ] );
        if (ret) {
            let img_arr = ret[uri];
            if (img_arr && img_arr.length) {
                return img_arr[0];
            }
        }
        return undefined;
    }
    private modpidyGetImagesForUris = async (uris: string[]) => {
        let ret_o = await this.sendRpcMessage<MopidyAPI.ReqLibraryImages>({ method: "core.library.get_images", params: { uris } });
        if (ret_o.result) {
            return ret_o.result;
        } else {
            return undefined;
        }
    }

    // @ts-ignore
    private storeTracklist = (tl_tracks: MopidyAPI.TlTrack[]) => {
        // Todo!
    }

    private parseEvent = async (event_o: MopidyAPI.Event): Promise<boolean> => {
        switch (event_o.event) {
            case "stream_title_changed": {
                if (event_o.title && event_o.title != "") {
                    this.playstate.stream_title = event_o.title;
                } else {
                    delete this.playstate.stream_title;
                }
                this.transmitPlaystate();
                return true;
            }
            case "playback_state_changed": {
                console.debug(`PlayStateChanged: ${event_o.old_state} -> ${event_o.new_state}`);
                await this.getPlayState();
                this.transmitPlaystate();
                return true;
            }
            case "tracklist_changed": {
                let tracklist = await this.mopidyGetTrackList();
                console.debug("retrieved tracklist: ", tracklist);
                this.storeTracklist(tracklist);
                await this.getState();
                this.transmitPlaystate();
                return true;
            }
            case "track_playback_started": {
                delete this.playstate.stream_title; // A new track, not yet clear if it is a stream, we must reset the stream_title!
                
                await this.getState();
                this.transmitPlaystate();
                return true;
            }
            case "track_playback_ended": {
                return true;
            }
            case "mute_changed": {
                if (event_o.mute !== undefined) {
                    if (!this.playstate.settings) {
                        this.playstate.settings = {};
                    }
                    this.playstate.settings.muted = event_o.mute; 
                }
                this.transmitPlaystate();
                return true;
            }
            default: {
                return false; // uncomment for typescript to force interpretion of all cases! Needs noImplicitReturns=true in tsconfig.json
            }
        }
    }

    private parseData = (data_o: MopidyAPI.Event | MopidyAPI.RpcResponse) => {
        if (data_o["event"]) {
            this.parseEvent(<MopidyAPI.Event> data_o);
        } else if (data_o["jsonrpc"] && !data_o["method"]) {
            let rpc_result = <MopidyAPI.RpcResponse> data_o;
            const id = rpc_result.id;
            const rpc_o = this.rpc_req_map[id];
            if (rpc_o) {
                if (rpc_result.error) {
                    console.error(`Req [ ${id} ] error response: `, rpc_result.error);
                    rpc_o.resolve({ err: rpc_result.error.data?.message });
                } else {
                    rpc_o.resolve({ result: <MopidyAPI.RpcRequests['r']> rpc_result.result});
                }
                clearTimeout(rpc_o.timeout);
                delete this.rpc_req_map[id];
            } else {
                console.warn(`Could not find rpc response for id ${id}. Timed out already?`);
            }
        }
    }

    private rcvDataFromWebsocket = (str: string) => {
        if (str && str.startsWith("{")) {
            try {
                const data_o = JSON.parse(str);
                if (LOG_VERBOSE) {
                    // this is not needed, it leads to duplicate logging! Only for debugging
                    console.debug(`MopidyDataReceived: `, data_o);
                }
                this.parseData(data_o);
            } catch(e) {
                console.info(`MopidyDataReceived: error parsing: `,str, e);
            }
        } else {
            console.warn(`MopidyDataReceived: UnknownString: ` + str);
        }
    }

    public dataRequest: ScriptCtxUI.DataRequestCallback<"music_player"> = async (_req) => {
        return this.getDataEventFromCache();
    };

    private getPlayState = async () => {
        let res = await this.sendRpcMessage<MopidyAPI.ReqPlaybackGetState>({ method: 'core.playback.get_state' });
        if (!res.err) {
            let state = res.result;
            console.debug("getPlayState: result: ", state);
            if (state && state !== this.playstate.state) {
                this.playstate.state = state;
            }
            return state;
        } else {
            console.error("getPlayState: Error: ", res.err);
        }
        return undefined;
    }

    public executeCommand: ScriptCtxUI.CommandCallback<"music_player"> = async (cmd, _env) => {
        let method = cmd.method;
        console.debug("received command: ", cmd);
        if (method == "control:stop" || method == "control:pause" || method == "control:play" || method == "control:playpause") {
            if (method == "control:stop") {
                await this.sendRpcMessage({ method: 'core.playback.stop' });
            } else if (method == "control:pause") {
                await this.sendRpcMessage({ method: 'core.playback.pause' });
            } else if (method == "control:play") {
                await this.sendRpcMessage({ method: 'core.playback.play' });
            } else if (method == "control:playpause") {
                let state = await this.getPlayState();
                if (state) {
                    if (state == "playing") {
                        await this.sendRpcMessage({ method: 'core.playback.pause' });
                    } else {
                        await this.sendRpcMessage({ method: 'core.playback.resume' });
                    }
                }
            }
            return {
                method
            }
        } else if (cmd.method == "control:random") {
        }
        return undefined;
    }

    demoReceiveMqttMsg = (topic: string, _data: string) => {
        console.log("demoReceiveMqttMsg:", topic);
    }
}

export const script = new MyScript();